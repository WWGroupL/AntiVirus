#pragma once
#include "GlobalVars.h"
#include <string>
#include <iostream>
#include <filesystem>

namespace MalwareScanner {

	//Namespace definitions
	//Default ones added by win forms - System::IO used in reading files too
	using namespace System;
	using namespace System::IO;
	using namespace System::ComponentModel;
	using namespace System::Collections;
	using namespace System::Windows::Forms;
	using namespace System::Data;
	using namespace System::Drawing;
	//Win32 for reading registry
	using namespace Microsoft::Win32;
	//For reading network information
	using namespace System::Net;
	using namespace System::Net::NetworkInformation;
	//Global variables stored in GlobalVars.h
	using namespace Globals;
	using namespace System::Security::Cryptography;
	using namespace System::Threading::Tasks;
	namespace fs = std::filesystem;
	

	/// <summary>
	/// Summary for scan_report
	/// </summary>
	public ref class live_scan_report : public System::Windows::Forms::Form
	{
	public: int count = 0;
	static array<String^>^ compareArrays = gcnew array<String^>{"AABBCC", "AABB", "AABBCCDDEE"};

	public:
		live_scan_report(void)
		{
			InitializeComponent();
			//
			//TODO: Add the constructor code here
			//
		}

	public: 
		void AHandler(Object^ sender, EventArgs^ args) {
			MessageBox::Show("Called!");
		}

	protected:
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		~live_scan_report()
		{
			if (components)
			{
				delete components;
			}
		}

	protected:

	private: System::Windows::Forms::ProgressBar^ progressBar1;

	private: System::Windows::Forms::Label^ lblTitle;
	private: System::Windows::Forms::ListBox^ scan_results_list;

	private:
		/// <summary>
		/// Required designer variable.
		/// </summary>
		System::ComponentModel::Container ^components;

#pragma region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		void InitializeComponent(void)
		{
			System::ComponentModel::ComponentResourceManager^ resources = (gcnew System::ComponentModel::ComponentResourceManager(live_scan_report::typeid));
			this->progressBar1 = (gcnew System::Windows::Forms::ProgressBar());
			this->lblTitle = (gcnew System::Windows::Forms::Label());
			this->scan_results_list = (gcnew System::Windows::Forms::ListBox());
			this->SuspendLayout();
			// 
			// progressBar1
			// 
			this->progressBar1->ForeColor = System::Drawing::SystemColors::ControlText;
			this->progressBar1->Location = System::Drawing::Point(12, 659);
			this->progressBar1->Name = L"progressBar1";
			this->progressBar1->Size = System::Drawing::Size(1318, 25);
			this->progressBar1->Style = System::Windows::Forms::ProgressBarStyle::Continuous;
			this->progressBar1->TabIndex = 1;
			// 
			// lblTitle
			// 
			this->lblTitle->AutoSize = true;
			this->lblTitle->Font = (gcnew System::Drawing::Font(L"Verdana", 36, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->lblTitle->ForeColor = System::Drawing::SystemColors::ControlLightLight;
			this->lblTitle->Location = System::Drawing::Point(449, 35);
			this->lblTitle->Name = L"lblTitle";
			this->lblTitle->Size = System::Drawing::Size(588, 59);
			this->lblTitle->TabIndex = 3;
			this->lblTitle->Text = L"Scanning In Progress...";
			// 
			// scan_results_list
			// 
			this->scan_results_list->BackColor = System::Drawing::Color::FromArgb(static_cast<System::Int32>(static_cast<System::Byte>(66)),
				static_cast<System::Int32>(static_cast<System::Byte>(66)), static_cast<System::Int32>(static_cast<System::Byte>(66)));
			this->scan_results_list->BorderStyle = System::Windows::Forms::BorderStyle::FixedSingle;
			this->scan_results_list->Font = (gcnew System::Drawing::Font(L"Consolas", 12, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->scan_results_list->ForeColor = System::Drawing::SystemColors::Info;
			this->scan_results_list->FormattingEnabled = true;
			this->scan_results_list->HorizontalScrollbar = true;
			this->scan_results_list->ItemHeight = 19;
			this->scan_results_list->Location = System::Drawing::Point(12, 114);
			this->scan_results_list->Name = L"scan_results_list";
			this->scan_results_list->Size = System::Drawing::Size(1318, 496);
			this->scan_results_list->TabIndex = 4;
			this->scan_results_list->SelectedIndexChanged += gcnew System::EventHandler(this, &live_scan_report::scan_results_list_SelectedIndexChanged);
			// 
			// live_scan_report
			// 
			this->AutoScaleDimensions = System::Drawing::SizeF(6, 14);
			this->AutoScaleMode = System::Windows::Forms::AutoScaleMode::Font;
			this->BackColor = System::Drawing::Color::FromArgb(static_cast<System::Int32>(static_cast<System::Byte>(36)), static_cast<System::Int32>(static_cast<System::Byte>(36)),
				static_cast<System::Int32>(static_cast<System::Byte>(36)));
			this->ClientSize = System::Drawing::Size(1337, 749);
			this->Controls->Add(this->scan_results_list);
			this->Controls->Add(this->lblTitle);
			this->Controls->Add(this->progressBar1);
			this->Font = (gcnew System::Drawing::Font(L"Times New Roman", 8.25F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->ForeColor = System::Drawing::SystemColors::Menu;
			this->Icon = (cli::safe_cast<System::Drawing::Icon^>(resources->GetObject(L"$this.Icon")));
			this->MaximizeBox = false;
			this->MinimizeBox = false;
			this->Name = L"live_scan_report";
			this->StartPosition = System::Windows::Forms::FormStartPosition::CenterScreen;
			this->Text = L"Scanning...";
			this->Load += gcnew System::EventHandler(this, &live_scan_report::scan_report_Load);
			this->ResumeLayout(false);
			this->PerformLayout();

		}
#pragma endregion
	private: System::Void scan_report_Load(System::Object^ sender, System::EventArgs^ e) {
		//Decide what scans to run, based on checkboxes from the form before, using global variables to pass
		//information between forms.
		//I'll admit, not very efficent for expansion, but can you blame me Andrew?
		//https://www.c-sharpcorner.com/UploadFile/834980/how-to-pass-data-from-one-form-to-other-form-in-windows-form/
		if (GlobalVariables::bool_startupSelected) {
			startUpScan();
		}
		progressBar1->Value = 33;
		if (GlobalVariables::bool_networkSelected) {
			networkScan();
		}
		progressBar1->Value = 67;
		if (GlobalVariables::bool_diskSelected) {
			diskScan();
		}
		progressBar1->Value = 100;
	}

	/* --== Scanning functions ==--
	 Written by James Kluver (Startup scan)
	 and
	*/


	/* Startup Scan - James Kluver
	
	References
	[1] How to read registry keys - copied code snippet, heavy use in registryRead()
	https://docs.microsoft.com/en-us/cpp/dotnet/windows-operations-cpp-cli?view=msvc-160#read_registry
	.NET documentation covers the Registry function used here
	https://docs.microsoft.com/en-us/dotnet/api/microsoft.win32.registrykey?view=net-5.0

	[2] How to write to text files - copied code snippet, heavy use in startUpScan and putItemInList
	https://docs.microsoft.com/en-us/cpp/dotnet/file-handling-and-i-o-cpp-cli?view=msvc-160#write_text

	[3] How to enumarate files
	https://docs.microsoft.com/en-us/cpp/dotnet/file-handling-and-i-o-cpp-cli?view=msvc-160#enumerate

	[4] For string formatting (more just learning what it does, not code samples)
	https://docs.microsoft.com/en-us/dotnet/api/system.string.format?view=net-5.0

	[5] Learning try-catch syntax
	https://docs.microsoft.com/en-us/cpp/dotnet/differences-in-exception-handling-behavior-under-clr?view=msvc-160
	*/

	//Functions
	/*
	Function scans registry keys and startup folders to find what programs run on start up
	*/
	int startUpScan() {
		//Initate text file which holds the return values [2]
		String^ fileName = "startup_scan_results.txt";
		StreamWriter^ sw = gcnew StreamWriter(fileName);

		//Array of subkey paths to find programs run on startup
		array<String^>^ paths = {
			"Microsoft\\Windows\\CurrentVersion\\Run",
			"Microsoft\\Windows\\CurrentVersion\\RunOnce",
			"Microsoft\\Windows\\CurrentVersion\\RunServices",
			"Microsoft\\Windows\\CurrentVersion\\RunServicesOnce",
			"Microsoft\\Windows\\CurrentVersion\\RunOnce\\Setup",
			"Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\RunOnce\\Setup"
		};

		//Add headers to make it look pretty - just not to the text file
		scan_results_list->BeginUpdate();
		scan_results_list->Items->Add("Startup scan");
		scan_results_list->Items->Add("=========================================================================================================================================================");
		String^ header = String::Format("{0,-40} |  {1}", "Name", "Location");
		scan_results_list->Items->Add(header);
		scan_results_list->Items->Add("=========================================================================================================================================================");
		scan_results_list->EndUpdate();
		
		//64 bit windows has a registry Wow6432Node for 32-bit processes
		//It's supposed to be a mirror but it isn't - meaning on 64 bit windows we have to look in both places
		//This mean we could get duplicates - these aren't currently handled, but I have yet to see one
		if (Environment::Is64BitOperatingSystem)
		{
			for (int i = 0; i < paths->Length; i++) {
				registryRead("SOFTWARE\\" + paths[i], sw);
				registryRead("SOFTWARE\\Wow6432Node\\" + paths[i], sw);
			}
		}
		else
		{
			for (int i = 0; i < paths->Length; i++) {
				registryRead("SOFTWARE\\" + paths[i], sw);
			}
		}

		//Enumarate startup directories
		directoryRead("C:\\Users\\" + Environment::UserName + "\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup", sw);
		directoryRead("C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup", sw);

		//Make the end look nice
		scan_results_list->BeginUpdate();
		scan_results_list->Items->Add("=========================================================================================================================================================");
		scan_results_list->Items->Add("");
		scan_results_list->EndUpdate();
		//Exit gracefully
		sw->Close();
		return 0;
	}


	/*
		Function will view all keys for a given subkey given in registryPath
		for both HKEY_LOCAL_MACHINE and HKEY_CURRENT_USER root keys [1]
		and write them to open text file via stream writer [2]
	*/
	int registryRead(String^ registryPath, StreamWriter^ sw) {

		//First checks the HKEY_LOCAL_MACHINE root
		RegistryKey^ rk = nullptr;
		rk = Registry::LocalMachine->OpenSubKey(registryPath);
		String^ value;

		if (rk != nullptr) {
			array<String^>^ names = rk->GetValueNames();
			
			for (int i = 0; i < names->Length; i++) {
				value = rk->GetValue(names[i])->ToString();
				array<String^>^ results = gcnew array<String^> {names[i], value};
				pushItemToList(sw, "{0,-40} |  {1}", results);
			}
		}
		
		//Then checks the HKEY_CURRENT_USER root key
		rk = nullptr;
		rk = Registry::CurrentUser->OpenSubKey(registryPath);

		if (rk != nullptr) {
			array<String^>^ names = rk->GetValueNames();
			
			for (int i = 0; i < names->Length; i++) {
				value = rk->GetValue(names[i])->ToString();
				array<String^>^ results = gcnew array<String^> {names[i], value};
				pushItemToList(sw, "{0,-40} |  {1}", results);
			}
		}
		return 0;
	}

	/*
		Function reads list of files in given folder [3] - it sends this info to pushItemToList
	*/
	int directoryRead(String^ folder, StreamWriter^ sw) {
		//Handles if file can't be found [5]
		try {
			array<String^>^ file = Directory::GetFiles(folder);
		}
		catch (IOException^) {
			sw->WriteLine("Path {0} not found - could be invalid or path doesn't exist", folder);
			return 1;
		}

		//Memory efficiency? wait people actually care about that?
		array<String^>^ file = Directory::GetFiles(folder);
		String^ name;
		//Iterate through files in given folder, write there names and locations
		for (int i = 0; i < file->Length; i++) {
			name = file[i]->Substring((folder->Length + 1));
			array<String^>^ results = gcnew array<String^>{ name, file[i] };
			pushItemToList(sw, "{0,-40} |  {1}", results);
		}
		return 0;
	}

	/*
		Function displays results of scan, by writing to the list on the form and to a text file to be seen later
	*/
	int pushItemToList(StreamWriter^ sw, String^ formatString, array<String^>^ columns) {
		scan_results_list->BeginUpdate();
		String^ listEntry = String::Format(formatString, columns);
		scan_results_list->Items->Add(listEntry);
		sw->WriteLine(listEntry);
		scan_results_list->EndUpdate();
		return 0;
	}

	/* Network scan - James Kluver
	
	References
	[6] Getting network activity
	https://stackoverflow.com/questions/24899948/netstat-focus-on-find-port
	Code sample taken from here - heavy usage
	https://docs.microsoft.com/en-us/dotnet/api/system.net.networkinformation.tcpconnectioninformation?view=net-5.0
	*/
	int networkScan() {
		//Initate text file which holds the return values [2]
		String^ fileName = "network_scan_results.txt";
		StreamWriter^ sw = gcnew StreamWriter(fileName);

		//Create header in list
		scan_results_list->BeginUpdate();
		scan_results_list->Items->Add("Network scan");
		scan_results_list->Items->Add("=========================================================================================================================================================");
		String^ header = String::Format("{0,-20} |  {1,-20} |  {2}", "Local", "Remote", "Note");
		scan_results_list->Items->Add(header);
		scan_results_list->Items->Add("=========================================================================================================================================================");
		scan_results_list->EndUpdate();

		IPGlobalProperties^ listenersArray = IPGlobalProperties::GetIPGlobalProperties();
		array<TcpConnectionInformation^>^ connections = listenersArray->GetActiveTcpConnections();
		IPEndPoint^ localEP;
		IPEndPoint^ remoteEP;
		String^ note;

		for (int i = 0; i < connections->Length; i++) {
			localEP = connections[i]->LocalEndPoint;
			remoteEP = connections[i]->RemoteEndPoint;
			note = "";
			if (remoteEP->Address->IsLoopback(remoteEP->Address) ) {
				note += "This is services talking to each other within your computer - this doesn't connect out the the wider network;";
			}
			if (remoteEP->Port == 80) {
				note += "This connects to port 80, so it's probably a HTTP connection;";
			}
			if (remoteEP->Port == 443) {
				note += "This connects to port 443, so it's probably a HTTPS connection;";
			}
			array<String^>^ results = gcnew array<String^> {
				localEP->ToString(),
				remoteEP->ToString(),
				note
			};
			pushItemToList(sw, "{0,-20} |  {1,-20} |  {2}", results);
		}

		scan_results_list->BeginUpdate();
		scan_results_list->Items->Add("=========================================================================================================================================================");
		scan_results_list->Items->Add("");
		scan_results_list->EndUpdate();

		//End peacefully
		sw->Close();
		return 0;
	}

	/*
	Disk scan
	*/
	int diskScan() {
		// The purpose of this function is to scan the filesystem and determine if any file hashes match known malicious

		String^ rootDir = gcnew String("C:\\Users\\Alex\\Documents\\NodeDev");
		Parallel::ForEach(Directory::EnumerateFiles(rootDir, "*.*", SearchOption::AllDirectories), gcnew Action<String^>(this, &live_scan_report::async_hash_file));

		scan_results_list->Items->Add("Disk scan ran");
		scan_results_list->Items->Add(count.ToString() + " Files");

		return 0;
	}
	public: SHA1^ hash_service = SHA1::Create();

	void async_hash_file(String^ filepath) {
		/* This function is called from parallel foreach,
		* meaning that the thread that the code will execute from
		* is indeterminate. Purpose of function is to hash file and compare to hash list
		*/
		String^ byteString = "";
		try {
			// Read File
			FileStream^ fs = File::OpenRead(filepath);
			// Create Hash
			byteString = BitConverter::ToString(hash_service->ComputeHash(fs))->Replace("-","");
			// Compare Hash
			if (Array::IndexOf(compareArrays, byteString) != -1) {
				MessageBox::Show("Match found");
			}
		}
		catch (Exception^ e) {
		}


	}

private: System::Void scan_results_list_SelectedIndexChanged(System::Object^ sender, System::EventArgs^ e) {
}
};
}