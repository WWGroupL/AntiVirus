#pragma once
#include "GlobalVars.h"
#include <string>
#include <iostream>
#include <filesystem>
#include <fstream>
#include <msclr\marshal_cppstd.h>

namespace MalwareScanner {

	//Namespace definitions
	//Default ones added by win forms - System::IO used in reading files too
	using namespace System;
	using namespace System::IO;
	using namespace System::ComponentModel;
	using namespace System::Collections;
	using namespace System::Windows::Forms;
	using namespace System::Data;
	using namespace System::Drawing;
	//Win32 for reading registry
	using namespace Microsoft::Win32;
	//For reading network information
	using namespace System::Net;
	using namespace System::Net::NetworkInformation;
	//Global variables stored in GlobalVars.h
	using namespace Globals;
	using namespace System::Security::Cryptography;
	using namespace System::Threading::Tasks;
	namespace fs = std::filesystem;
	

	/// <summary>
	/// Summary for scan_report
	/// </summary>
	public ref class live_scan_report : public System::Windows::Forms::Form
	{
	public: int numberOfFiles = 0;
	public: int outputArrayIndex = 0;
	static array<String^>^ outputArrays = gcnew array<String^>(1000);

	static array<String^>^ compareArrays = gcnew array<String^>{"055BEEA17D1656E3123CB46BFC34FCFE", "68021C00376EE77D760F054EE349CD0D"};


	public:
		live_scan_report(void)
		{
			InitializeComponent();
			//
			//TODO: Add the constructor code here
			//
		}

	public: 
		void AHandler(Object^ sender, EventArgs^ args) {
			MessageBox::Show("Called!");
		}

	protected:
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		~live_scan_report()
		{
			if (components)
			{
				delete components;
			}
		}

	protected:

	private: System::Windows::Forms::ProgressBar^ progressBar1;

	private: System::Windows::Forms::Label^ lblTitle;
	private: System::Windows::Forms::ListBox^ scan_results_list;

	private:
		/// <summary>
		/// Required designer variable.
		/// </summary>
		System::ComponentModel::Container ^components;

#pragma region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		void InitializeComponent(void)
		{
			System::ComponentModel::ComponentResourceManager^ resources = (gcnew System::ComponentModel::ComponentResourceManager(live_scan_report::typeid));
			this->progressBar1 = (gcnew System::Windows::Forms::ProgressBar());
			this->lblTitle = (gcnew System::Windows::Forms::Label());
			this->scan_results_list = (gcnew System::Windows::Forms::ListBox());
			this->SuspendLayout();
			// 
			// progressBar1
			// 
			this->progressBar1->ForeColor = System::Drawing::SystemColors::ControlText;
			this->progressBar1->Location = System::Drawing::Point(12, 659);
			this->progressBar1->Name = L"progressBar1";
			this->progressBar1->Size = System::Drawing::Size(1318, 25);
			this->progressBar1->Style = System::Windows::Forms::ProgressBarStyle::Continuous;
			this->progressBar1->TabIndex = 1;
			// 
			// lblTitle
			// 
			this->lblTitle->AutoSize = true;
			this->lblTitle->Font = (gcnew System::Drawing::Font(L"Verdana", 36, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->lblTitle->ForeColor = System::Drawing::SystemColors::ControlLightLight;
			this->lblTitle->Location = System::Drawing::Point(449, 35);
			this->lblTitle->Name = L"lblTitle";
			this->lblTitle->Size = System::Drawing::Size(738, 73);
			this->lblTitle->TabIndex = 3;
			this->lblTitle->Text = L"Scanning In Progress...";
			// 
			// scan_results_list
			// 
			this->scan_results_list->BackColor = System::Drawing::Color::FromArgb(static_cast<System::Int32>(static_cast<System::Byte>(66)),
				static_cast<System::Int32>(static_cast<System::Byte>(66)), static_cast<System::Int32>(static_cast<System::Byte>(66)));
			this->scan_results_list->BorderStyle = System::Windows::Forms::BorderStyle::FixedSingle;
			this->scan_results_list->Font = (gcnew System::Drawing::Font(L"Consolas", 12, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->scan_results_list->ForeColor = System::Drawing::SystemColors::Info;
			this->scan_results_list->FormattingEnabled = true;
			this->scan_results_list->HorizontalScrollbar = true;
			this->scan_results_list->ItemHeight = 23;
			this->scan_results_list->Location = System::Drawing::Point(12, 114);
			this->scan_results_list->Name = L"scan_results_list";
			this->scan_results_list->Size = System::Drawing::Size(1318, 485);
			this->scan_results_list->TabIndex = 4;
			this->scan_results_list->SelectedIndexChanged += gcnew System::EventHandler(this, &live_scan_report::scan_results_list_SelectedIndexChanged);
			// 
			// live_scan_report
			// 
			this->AutoScaleDimensions = System::Drawing::SizeF(8, 16);
			this->AutoScaleMode = System::Windows::Forms::AutoScaleMode::Font;
			this->BackColor = System::Drawing::Color::FromArgb(static_cast<System::Int32>(static_cast<System::Byte>(36)), static_cast<System::Int32>(static_cast<System::Byte>(36)),
				static_cast<System::Int32>(static_cast<System::Byte>(36)));
			this->ClientSize = System::Drawing::Size(1337, 749);
			this->Controls->Add(this->scan_results_list);
			this->Controls->Add(this->lblTitle);
			this->Controls->Add(this->progressBar1);
			this->Font = (gcnew System::Drawing::Font(L"Times New Roman", 8.25F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->ForeColor = System::Drawing::SystemColors::Menu;
			this->Icon = (cli::safe_cast<System::Drawing::Icon^>(resources->GetObject(L"$this.Icon")));
			this->MaximizeBox = false;
			this->MinimizeBox = false;
			this->Name = L"live_scan_report";
			this->StartPosition = System::Windows::Forms::FormStartPosition::CenterScreen;
			this->Text = L"Scanning...";
			this->Load += gcnew System::EventHandler(this, &live_scan_report::live_scan_report_Load);
			this->Shown += gcnew System::EventHandler(this, &live_scan_report::scan_report_Load);
			this->ResumeLayout(false);
			this->PerformLayout();

		}
#pragma endregion
	private: System::Void scan_report_Load(System::Object^ sender, System::EventArgs^ e) {

		//Set up text file to save scans [1] - file's of format "*-scan_report.txt" are ignored in .gitignore
		//File name has date and time [2] stored in it so it can be reviewed lated in previous scans
		String^ location = "C:\\Users\\" + Environment::UserName + "\\AppData\\LocalLow\\McAffront_AVirus_SafeToDelete\\";
		String^ reportName = String::Format("{0:dd-MM-yyyy-hh-mm-ss}-scan_report.txt", DateTime::Now);
		StreamWriter^ scanTextReport = gcnew StreamWriter(location + reportName);
		pushItemToList(scanTextReport, reportName);

		//Decide what scans to run, based on checkboxes from the form before, using global variables to pass information between forms.
		if (GlobalVariables::bool_startupSelected) {
			startUpScan(scanTextReport);
		}
		progressBar1->Value = 33;
		if (GlobalVariables::bool_networkSelected) {
			networkScan(scanTextReport);
		}
		progressBar1->Value = 67;
		if (GlobalVariables::bool_diskSelected) {
			auto fbr = gcnew System::Windows::Forms::FolderBrowserDialog();
			auto result = fbr->ShowDialog();
			String^ rootDir;

			if (result == System::Windows::Forms::DialogResult::OK) {
				rootDir = fbr->SelectedPath;
				diskScan(scanTextReport, rootDir);
			}
		}
		progressBar1->Value = 100;
		lblTitle->Text = "Scan complete";
		scanTextReport->Close();
	}
	/* References - James Kluver
	[1] How to write to text files - copied code snippet, heavy use in scan_report_load (see above) and putItemInList()
		https://docs.microsoft.com/en-us/cpp/dotnet/file-handling-and-i-o-cpp-cli?view=msvc-160#write_text

	[2] Custom formats for dates - used in scan_report_load (see above)
		https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings
		   
	[3] How to read registry keys - copied code snippet, heavy use in registryRead()
		https://docs.microsoft.com/en-us/cpp/dotnet/windows-operations-cpp-cli?view=msvc-160#read_registry
		.NET documentation covers the Registry function used here
		https://docs.microsoft.com/en-us/dotnet/api/microsoft.win32.registrykey?view=net-5.0

	[4] How to enumarate files - code snippet used in directoryRead()
		https://docs.microsoft.com/en-us/cpp/dotnet/file-handling-and-i-o-cpp-cli?view=msvc-160#enumerate

	[5] String formatting - use in most functions
		https://docs.microsoft.com/en-us/dotnet/api/system.string.format?view=net-5.0

	[6] Learning try-catch syntax - use in directoryRead()
		https://docs.microsoft.com/en-us/cpp/dotnet/differences-in-exception-handling-behavior-under-clr?view=msvc-160

	[7] Getting network activity
		https://stackoverflow.com/questions/24899948/netstat-focus-on-find-port
		Code sample taken from here - heavy usage
		https://docs.microsoft.com/en-us/dotnet/api/system.net.networkinformation.tcpconnectioninformation?view=net-5.0
	*/

	/* --== Scanning functions ==--
	 Written by James Kluver (Startup scan and Network)
	 and
	*/


	//Startup Scan - James Kluver

	//Functions

	/* startUpScan
		Function scans registry keys and startup folders and prints the names and locations
		of programs that run on startup
	*/
	int startUpScan(StreamWriter^ sw) {
		//Array of subkey paths to find programs run on startup
		array<String^>^ paths = {
			"Microsoft\\Windows\\CurrentVersion\\Run",
			"Microsoft\\Windows\\CurrentVersion\\RunOnce",
			"Microsoft\\Windows\\CurrentVersion\\RunServices",
			"Microsoft\\Windows\\CurrentVersion\\RunServicesOnce",
			"Microsoft\\Windows\\CurrentVersion\\RunOnce\\Setup",
			"Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\RunOnce\\Setup"
		};

		//Add headers for formatting
		pushItemToList(sw, "Startup scan");
		pushItemToList(sw, "=========================================================================================================================================================");
		String^ header = String::Format("{0,-40} |  {1}", "Name", "Location");
		pushItemToList(sw, header);
		pushItemToList(sw, "=========================================================================================================================================================");
		
		//64 bit windows has a registry Wow6432Node for 32-bit processes
		//It's supposed to be a mirror but it isn't - meaning on 64 bit windows we have to look in both places
		//This mean we could get duplicates - these aren't currently handled, but I have yet to see one
		if (Environment::Is64BitOperatingSystem)
		{
			for (int i = 0; i < paths->Length; i++) {
				registryRead("SOFTWARE\\" + paths[i], sw);
				registryRead("SOFTWARE\\Wow6432Node\\" + paths[i], sw);
			}
		}
		else
		{
			for (int i = 0; i < paths->Length; i++) {
				registryRead("SOFTWARE\\" + paths[i], sw);
			}
		}

		//Enumarate startup directories [4]
		directoryRead("C:\\Users\\" + Environment::UserName + "\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup", sw);
		directoryRead("C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup", sw);

		//Make the end look nice
		pushItemToList(sw, "=========================================================================================================================================================");
		pushItemToList(sw, "");
		//Exit gracefully
		//sw->Close();
		return 0;
	}


	/* registryRead - used in startUpScan
		Function will view all keys for a given subkey given in registryPath for both HKEY_LOCAL_MACHINE and HKEY_CURRENT_USER root keys [1],
		and prints them using pushItemToList
	*/
	int registryRead(String^ registryPath, StreamWriter^ sw) {

		//First checks the HKEY_LOCAL_MACHINE root
		RegistryKey^ rk = nullptr;
		rk = Registry::LocalMachine->OpenSubKey(registryPath);
		String^ value;

		//If rk isn't null pointer (so if it's pointing to a registry key), then get the results
		if (rk != nullptr) {
			array<String^>^ names = rk->GetValueNames();
			
			for (int i = 0; i < names->Length; i++) {
				value = rk->GetValue(names[i])->ToString();
				array<String^>^ results = gcnew array<String^> {names[i], value};
				pushItemToList(sw, "{0,-40} |  {1}", results);
			}
		}
		
		//Then checks the HKEY_CURRENT_USER root key
		rk = nullptr;
		rk = Registry::CurrentUser->OpenSubKey(registryPath);

		if (rk != nullptr) {
			array<String^>^ names = rk->GetValueNames();
			
			for (int i = 0; i < names->Length; i++) {
				value = rk->GetValue(names[i])->ToString();
				array<String^>^ results = gcnew array<String^> {names[i], value};
				pushItemToList(sw, "{0,-40} |  {1}", results);
			}
		}
		return 0;
	}

	/* directoryRead - used in startUpScan
		Function reads list of files in given folder [3], which are printed by pushItemToList
	*/
	int directoryRead(String^ folder, StreamWriter^ sw) {
		//Handles if file can't be found [5]
		try {
			array<String^>^ file = Directory::GetFiles(folder);
		}
		catch (IOException^) {
			sw->WriteLine("Path {0} not found - could be invalid or path doesn't exist", folder);
			return 1;
		}

		array<String^>^ file = Directory::GetFiles(folder);
		String^ name;
		//Iterate through files in given folder, write there names and locations
		for (int i = 0; i < file->Length; i++) {
			name = file[i]->Substring((folder->Length + 1));
			array<String^>^ results = gcnew array<String^>{ name, file[i] };
			pushItemToList(sw, "{0,-40} |  {1}", results);
		}
		return 0;
	}

	/* pushItemToList - used in every function
		Function prints results of scan, by writing to the list on the form and to a text file to be seen later [1]
		I overloaded this function as it ideally needs a simple and complex version
		I learnt about that here
		https://www.pluralsight.com/guides/overload-methods-invoking-overload-methods-csharp
	*/
	//Print string to list
	int pushItemToList(StreamWriter^ sw, String^ text) {
		scan_results_list->BeginUpdate();
		scan_results_list->Items->Add(text);
		scan_results_list->EndUpdate();
		sw->WriteLine(text);
		return 0;
	}
	//Print formatted string to list using a given formatting string
	int pushItemToList(StreamWriter^ sw, String^ formatString, array<String^>^ columns) {
		scan_results_list->BeginUpdate();
		String^ listEntry = String::Format(formatString, columns);
		scan_results_list->Items->Add(listEntry);
		scan_results_list->EndUpdate();
		sw->WriteLine(listEntry);
		return 0;
	}

	//Network scan - James Kluver
	
	//Functions

	/* networkScan
		Goes through all the current TCP listeners and idsplays them to the user, with some notes explaining
		very common listeners
	*/
	int networkScan(StreamWriter^ sw) {

		//Create header in list
		pushItemToList(sw, "Network scan");
		pushItemToList(sw, "=========================================================================================================================================================");
		String^ header = String::Format("{0,-20} |  {1,-20} |  {2}", "Local", "Remote", "Note");
		pushItemToList(sw, header);
		pushItemToList(sw, "=========================================================================================================================================================");

		//Creates array of listeners [7]
		IPGlobalProperties^ listenersArray = IPGlobalProperties::GetIPGlobalProperties();
		array<TcpConnectionInformation^>^ connections = listenersArray->GetActiveTcpConnections();
		//Some recurring variables
		IPEndPoint^ localEP;
		IPEndPoint^ remoteEP;
		String^ note;

		//Go through array and print information (using pushItemToList)
		for (int i = 0; i < connections->Length; i++) {
			localEP = connections[i]->LocalEndPoint;
			remoteEP = connections[i]->RemoteEndPoint;
			note = "";
			if (remoteEP->Address->IsLoopback(remoteEP->Address) ) {
				note += "This is services talking to each other within your computer - this doesn't connect out the the wider network;";
			}
			if (remoteEP->Port == 80) {
				note += "This connects to port 80, so it's probably a HTTP connection;";
			}
			if (remoteEP->Port == 443) {
				note += "This connects to port 443, so it's probably a HTTPS connection;";
			}
			array<String^>^ results = gcnew array<String^> {localEP->ToString(), remoteEP->ToString(), note };
			pushItemToList(sw, "{0,-20} |  {1,-20} |  {2}", results);
		}

		pushItemToList(sw, "=========================================================================================================================================================");
		pushItemToList(sw, "");

		//End peacefully
		//sw->Close();
		return 0;
	}

	/* 
		Alex McCoy: diskScan() and async_hash_file()
		Owen Hunter: async_sig_file()
	*/
	int diskScan(StreamWriter^ sw, String^ rootDir) {
		// The purpose of this function is to scan the filesystem and determine if any file hashes match known malicious

		outputArrayIndex = 0;
		numberOfFiles = 0;

		// Enumerate selected directories and call async_hash_file on multiple threads
		try {
			Parallel::ForEach(Directory::EnumerateFiles(rootDir, "*.*", SearchOption::AllDirectories), gcnew Action<String^>(this, &live_scan_report::async_hash_file));
			Parallel::ForEach(Directory::EnumerateFiles(rootDir, "*.*", SearchOption::AllDirectories), gcnew Action<String^>(this, &live_scan_report::async_sig_file));
		}
		catch (Exception^ e) {
			outputArrayIndex++;
			outputArrays[outputArrayIndex] = "Error accessing directory: " + e;
		}


		pushItemToList(sw, "Disk scan");
		pushItemToList(sw, numberOfFiles.ToString() + " Files");
		pushItemToList(sw, "=========================================================================================================================================================");

		// Push the results
		for (int i = 0; i < outputArrays->Length - 1; i++) {
			if (outputArrays[i]) {
				pushItemToList(sw, outputArrays[i]);
				outputArrays[i] = "";
			}
		}
		pushItemToList(sw, "=========================================================================================================================================================");

		return 0;
	}

	void async_hash_file(String^ filepath) {
		/* This function is called from parallel foreach,
		* meaning that the thread that the code will execute from
		* is indeterminate. Purpose of function is to hash file and compare to hash list
		*/

		// Create MD5 service on current thread.
		MD5^ hash_service = MD5::Create();

		// Store the MD5 hash
		String^ byteString = "";

		try {
			// Read File
			auto fs = File::ReadAllBytes(filepath);
			
			//std::string unmanaged = msclr::interop::marshal_as<std::string>(filepath);
			//std::cout << "disk " << unmanaged << "\n";

			numberOfFiles++;
			// Create Hash
			byteString = BitConverter::ToString(hash_service->ComputeHash(fs))->Replace("-","");
			// Compare Hash
			if (Array::IndexOf(compareArrays, byteString) >= 0) {
				outputArrayIndex++;
				outputArrays[outputArrayIndex] = filepath + " identified as potentially malicious";
			}
		}
		catch (Exception^ e) {
			outputArrayIndex++;
			outputArrays[outputArrayIndex] = "Error scanning " + filepath;
		}
	}

	void async_sig_file(String^ filepath) {
		/*
			Using the same parallel threading as async_hash_file
		*/

		String^ byteString = "";

		try {
			//Read file bytes
			auto fs = File::ReadAllBytes(filepath);
			byteString = BitConverter::ToString(fs);
			// Convert byteString from String^ into std::string
			std::string strByteString = msclr::interop::marshal_as<std::string>(byteString);

			//std::string unmanaged = msclr::interop::marshal_as<std::string>(filepath);
			//std::cout << "sig " << unmanaged << "\n";

			//Open file database
			std::ifstream sigDBFile("signatureDB.txt");
			std::string str;
			//Enumerate through file database
			while (std::getline(sigDBFile, str)) {
				//Check if the signature is found in the file opened
				if (strByteString.find(str) != std::string::npos) {
					outputArrayIndex++;
					outputArrays[outputArrayIndex] = filepath + " identified as potentially malicious w/signature"; 
				}
			}
			sigDBFile.close();
		}
		catch (Exception^ e) {
			outputArrayIndex++;
			outputArrays[outputArrayIndex] = "Error scanning " + filepath;
		}
	}

private: System::Void scan_results_list_SelectedIndexChanged(System::Object^ sender, System::EventArgs^ e) {
}
private: System::Void live_scan_report_Load(System::Object^ sender, System::EventArgs^ e) {
}
};
}